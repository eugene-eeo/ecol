!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AddColour	ecol/utils.go	/^func (cg *ColouringGraph) AddColour(colour uint) {$/;"	f
AddColours	ecol/utils.go	/^func (cg *ColouringGraph) AddColours(colours *bitset.BitSet) {$/;"	f
Alloc	ecol/graphcheck.go	/^func (gc *GraphCheckMetadata) Alloc() {$/;"	f
BITSET_H	xc/bitset.h	2;"	d
BITSET_INIT	xc/bitset.c	/^const bitset BITSET_INIT = 0;$/;"	v
CC	xc/Makefile	/^CC=gcc$/;"	m
CFLAGS	xc/Makefile	/^CFLAGS= -std=c99 -Ofast -march=native -finline-functions -flto -funroll-loops -mbmi2$/;"	m
ColouringGraph	ecol/utils.go	/^type ColouringGraph struct {$/;"	t
ColouringGraph	pyecol/utils.py	/^class ColouringGraph(Graph):$/;"	c
CopyInto	ecol/graph.go	/^func (g *Graph) CopyInto(h *Graph) {$/;"	f
DEBUG_CFLAGS	xc/Makefile	/^DEBUG_CFLAGS= -std=c99 -O0 -march=native -g -mbmi2$/;"	m
Degree	ecol/graph.go	/^func (g *Graph) Degree(u int) int {$/;"	f
ERBenchmark	ecol/erdos_renyi_task.go	/^type ERBenchmark struct {$/;"	t
ERParams	ecol/erdos_renyi_task.go	/^type ERParams struct {$/;"	t
Edge	ecol/graph.go	/^type Edge struct {$/;"	t
EdgeCount	ecol/graph.go	/^func (g *Graph) EdgeCount() int {$/;"	f
EdgeData	ecol/vm.go	/^func (vi VMInput) EdgeData() [][]int {$/;"	f
EdgeDataOutput	ecol/graphcheck.go	/^type EdgeDataOutput struct {$/;"	t
Edges	ecol/graph.go	/^func (g *Graph) Edges() []Edge {$/;"	f
FreesetInfo	ecol/counting_heuristic.go	/^type FreesetInfo struct {$/;"	t
GRAPH6_H	xc/graph6.h	2;"	d
GRAPH_H	xc/graph.h	2;"	d
Get	ecol/graph.go	/^func (g *Graph) Get(i, j int) int {$/;"	f
Get	ecol/utils.go	/^func (cg *ColouringGraph) Get(i, j int) int {$/;"	f
Graph	ecol/graph.go	/^type Graph struct {$/;"	t
Graph	pyecol/graph.py	/^class Graph:$/;"	c
GraphCheckConfig	ecol/graphcheck.go	/^type GraphCheckConfig struct {$/;"	t
GraphCheckMetadata	ecol/graphcheck.go	/^type GraphCheckMetadata struct {$/;"	t
Init	ecol/vm.go	/^func (vc *VMConfig) Init() {$/;"	f
NewGraph	ecol/graph.go	/^func NewGraph(n int) *Graph {$/;"	f
NextIndex	ecol/bf.go	/^func NextIndex(ix []int, lens int) {$/;"	f
NextUncolouredEdge	ecol/utils.go	/^func (cg *ColouringGraph) NextUncolouredEdge() Edge {$/;"	f
ResetColours	ecol/graph.go	/^func (g *Graph) ResetColours() {$/;"	f
Set	ecol/graph.go	/^func (g *Graph) Set(i, j, v int) {$/;"	f
Set	ecol/utils.go	/^func (cg *ColouringGraph) Set(i, j, v int) {$/;"	f
USAGE	xc/resmod.c	/^static char* USAGE = "usage: resmod <r> <m>\\n";$/;"	v	file:
Update	ecol/graphcheck.go	/^func (gc *GraphCheckMetadata) Update() {$/;"	f
VIZING_H	xc/vizing_heuristic.h	2;"	d
VMConfig	ecol/vm.go	/^type VMConfig struct {$/;"	t
VMInput	ecol/vm.go	/^type VMInput map[string]interface{}$/;"	t
VMOutput	ecol/vm.go	/^type VMOutput map[string]interface{}$/;"	t
Validate	ecol/graphcheck.go	/^func (gc *GraphCheckMetadata) Validate(config *GraphCheckConfig) bool {$/;"	f
WrapGraph	ecol/utils.go	/^func WrapGraph(g *Graph) *ColouringGraph {$/;"	f
XC_CFLAGS	xc/Makefile	/^XC_CFLAGS= -D 'XC_GRAPH_COLOUR=1'$/;"	m
_GNU_SOURCE	xc/cg.c	10;"	d	file:
_GNU_SOURCE	xc/gc.c	12;"	d	file:
_GNU_SOURCE	xc/resmod.c	8;"	d	file:
_GNU_SOURCE	xc/xc.c	13;"	d	file:
__delitem__	pyecol/graph.py	/^    def __delitem__(self, edge):$/;"	m	class:Graph	file:
__getitem__	pyecol/graph.py	/^    def __getitem__(self, edge):$/;"	m	class:Graph	file:
__init__	pyecol/graph.py	/^    def __init__(self, n):$/;"	m	class:Graph
__init__	pyecol/utils.py	/^    def __init__(self, n, edge_data):$/;"	m	class:ColouringGraph
__setitem__	pyecol/graph.py	/^    def __setitem__(self, edge, data):$/;"	m	class:Graph	file:
__setitem__	pyecol/utils.py	/^    def __setitem__(self, edge, colour):$/;"	m	class:ColouringGraph	file:
__slots__	pyecol/graph.py	/^    __slots__ = ('n', 'edge_data')$/;"	v	class:Graph
_find_endpoint_with_colour	xc/graph.c	/^int _find_endpoint_with_colour(graph* g, int u, int colour) {$/;"	f
a	xc/xc.c	/^  uint64_t a;$/;"	m	struct:xorshift64s_state	file:
add_colours	pyecol/utils.py	/^    def add_colours(self, colours):$/;"	m	class:ColouringGraph
adj	xc/gc.c	/^    bitset* adj;$/;"	m	struct:__anon4	file:
adj_mat_to_graph	scripts/geng.py	/^def adj_mat_to_graph(lines, n, delta=None, underfull=None, delta_core=None, is_semicore=False):$/;"	f
allocate_path_array	ecol/utils.go	/^func allocate_path_array(cg *ColouringGraph) []int {$/;"	f
allocate_path_array	xc/graph.c	/^int* allocate_path_array(graph* g) {$/;"	f
author	setup.py	/^    author="Eeo Jun",$/;"	v
author_email	setup.py	/^    author_email="141bytes@gmail.com",$/;"	v
benchmark	scripts/benchmarks.py	/^def benchmark():$/;"	f
bitset	xc/bitset.h	/^typedef int64_t bitset;$/;"	t
bitset_count	xc/bitset.c	/^int bitset_count(bitset a) {$/;"	f
bitset_first	xc/bitset.c	/^int bitset_first(bitset a) {$/;"	f
bitset_intersection	xc/bitset.c	/^bitset bitset_intersection(bitset a, bitset b) {$/;"	f
bitset_nthset	xc/bitset.c	/^int bitset_nthset(bitset a, int n) {$/;"	f
bitset_set	xc/bitset.c	/^bitset bitset_set(bitset bs, int pos, int val) {$/;"	f
bitset_test	xc/bitset.c	/^int bitset_test(bitset bs, int pos) {$/;"	f
bitset_union	xc/bitset.c	/^bitset bitset_union(bitset a, bitset b) {$/;"	f
brute_force_colour	ecol/bf.go	/^func brute_force_colour(cg *ColouringGraph) {$/;"	f
build_adj_list	ecol/bf.go	/^func build_adj_list(edges []Edge) [][2]Edge {$/;"	f
cg	xc/gen.py	/^cg = True$/;"	v
check_claim	check_claim.py	/^def check_claim(graphs, n, g):$/;"	f
check_core_delta	xc/gc.c	/^int check_core_delta(graphcheck* gc, int deg) {$/;"	f
check_valid_semicore	xc/gc.c	/^int check_valid_semicore(graphcheck *gc) {$/;"	f
colours_used	ecol/utils.go	/^func colours_used(cg *ColouringGraph) int {$/;"	f
colours_used	pyecol/utils.py	/^def colours_used(G: ColouringGraph):$/;"	f
colours_used	xc/graph.c	/^int colours_used(graph *g) {$/;"	f
complete_bipartite_graph	ecol/erdos_renyi_task.go	/^func complete_bipartite_graph(n int, m int) *ColouringGraph {$/;"	f
complete_bipartite_graph	pyecol/graph.py	/^def complete_bipartite_graph(n, m):$/;"	f
complete_graph	ecol/erdos_renyi_task.go	/^func complete_graph(k int) *ColouringGraph {$/;"	f
complete_graph	pyecol/graph.py	/^def complete_graph(k):$/;"	f
construct	data/check_claim.py	/^def construct(n):$/;"	f
construct	data/check_edge_critical.py	/^def construct(n):$/;"	f
construct	data/check_vertex_critical.py	/^def construct(n):$/;"	f
construct	data/produce_graphs.py	/^def construct(n, k):$/;"	f
contains_cycle	pyecol/utils.py	/^def contains_cycle(g: Graph, subset=None):$/;"	f
copy	pyecol/graph.py	/^    def copy(self):$/;"	m	class:Graph
copy	pyecol/utils.py	/^    def copy(cls, g: Graph):$/;"	m	class:ColouringGraph
core	xc/gc.c	/^    bitset core;$/;"	m	struct:__anon4	file:
core_delta	ecol/graphcheck.go	/^func core_delta(gc *GraphCheckMetadata, target int) bool {$/;"	f
cores	xc/gen.py	/^cores = 24$/;"	v
counting_colour	ecol/counting.go	/^func counting_colour(G *ColouringGraph) {$/;"	f
counting_colour	pyecol/counting.py	/^def counting_colour(G: ColouringGraph) -> ColouringGraph:$/;"	f
counting_heuristic_colour	ecol/counting_heuristic.go	/^func counting_heuristic_colour(G *ColouringGraph) {$/;"	f
cursor	xc/graph6.h	/^    int cursor;$/;"	m	struct:__anon1
cvt_graph	filter_isomorphic.py	/^def cvt_graph(edge_data):$/;"	f
cyclic_helper	scripts/graphgen.py	/^    def cyclic_helper(v, visited, parent):$/;"	f	function:is_cyclic
data	scripts/graphgen.py	/^                data = {$/;"	v
deg_core	scripts/geng.py	/^def deg_core(g):$/;"	f
deg_graph	scripts/graphgen.py	/^def deg_graph(n, m):$/;"	f
degree	pyecol/graph.py	/^    def degree(self, node):$/;"	m	class:Graph
degree	xc/gc.c	/^    int* degree;$/;"	m	struct:__anon4	file:
degrees	pyecol/graph.py	/^    def degrees(self):$/;"	m	class:Graph
delta	xc/gc.c	/^    int delta;$/;"	m	struct:__anon4	file:
description	setup.py	/^    description="Edge colouring package",$/;"	v
dfs	xc/gc.c	/^int dfs(int u, bitset* visited, graph g, int parent) {$/;"	f
dmacs2graph	pyecol/utils.py	/^def dmacs2graph(stream):$/;"	f
ed	scripts/graphgen.py	/^                ed = g.edge_data$/;"	v
edge	xc/graph.h	/^} edge;$/;"	t	typeref:struct:__anon3
edge_data	scripts/graphgen.py	/^                edge_data = [[-1 if x is False else x for x in row] for row in ed]$/;"	v
edge_data	scripts/relabel.py	/^        edge_data = u["edge_data"]$/;"	v
edges	pyecol/graph.py	/^    def edges(self):$/;"	m	class:Graph
edges	xc/graph.h	/^    int *edges;$/;"	m	struct:__anon2
erdos_renyi_graph	ecol/erdos_renyi_task.go	/^func erdos_renyi_graph(n int, p float64, seed int64) *Graph {$/;"	f
erdos_renyi_graph	pyecol/graph.py	/^def erdos_renyi_graph(n, p):$/;"	f
erdos_renyi_into	ecol/erdos_renyi_task.go	/^func erdos_renyi_into(n int, p float64, seed int64, g *Graph) {$/;"	f
erdos_renyi_task	ecol/erdos_renyi_task.go	/^func erdos_renyi_task() {$/;"	f
extend_core	xc/cg.c	/^int extend_core(graph core, int maxn, int delta, int attempts, int* allowed, graph* g, bitset* adj) {$/;"	f
fast_valid_edge_colouring	ecol/bf.go	/^func fast_valid_edge_colouring(g *Graph, adjList [][2]Edge) bool {$/;"	f
filter_isomorphic	filter_isomorphic.py	/^def filter_isomorphic(graphs):$/;"	f
find_edge_with_colour	pyecol/utils.py	/^def find_edge_with_colour(G: ColouringGraph, u, colour, prev=None):$/;"	f
find_edge_with_colour_subset	pyecol/utils.py	/^def find_edge_with_colour_subset(G: ColouringGraph, u, colour, subset: set):$/;"	f
find_endpoint_with_colour	ecol/utils.go	/^func find_endpoint_with_colour(cg *ColouringGraph, u int, colour int) int {$/;"	f
find_endpoint_with_colour_subset	ecol/utils.go	/^func find_endpoint_with_colour_subset(cg *ColouringGraph, u int, colour int, limit int) int {$/;"	f
free	xc/graph.h	/^    bitset* free; \/\/ Free colours for a node$/;"	m	struct:__anon2
g	scripts/graphgen.py	/^                g = gen_sparse_graph(k, n*k)$/;"	v
g	xc/gc.c	/^    graph* g;$/;"	m	struct:__anon4	file:
gc_perform	ecol/graphcheck.go	/^func gc_perform(config *GraphCheckConfig, vmConfig *VMConfig) {$/;"	f
gc_vm_task	ecol/graphcheck.go	/^func gc_vm_task(config *VMConfig, gc *GraphCheckMetadata) int {$/;"	f
gen_sparse_graph	scripts/graphgen.py	/^def gen_sparse_graph(k, n, m=5):$/;"	f
generate_graphs	scripts/gen_nx.py	/^def generate_graphs(delta, n, repeats=1000, underfull=True):$/;"	f
generate_graphs	scripts/geng.py	/^def generate_graphs(args):$/;"	f
generate_graphs	scripts/geng_raw.py	/^def generate_graphs(args):$/;"	f
get_adj_dict	filter_isomorphic.py	/^def get_adj_dict(edge_data):$/;"	f
get_path	ecol/utils.go	/^func get_path(cg *ColouringGraph, v int, alpha, beta int, path []int) []int {$/;"	f
get_path	pyecol/utils.py	/^def get_path(G: ColouringGraph, v, alpha, beta) -> [int]:$/;"	f
get_path	xc/graph.c	/^int get_path(graph* g, int v, int alpha, int beta, int* path) {$/;"	f
get_path_subset	ecol/utils.go	/^func get_path_subset(cg *ColouringGraph, v int, alpha, beta int, path []int, limit int) []int {$/;"	f
get_path_subset	pyecol/utils.py	/^def get_path_subset(G: ColouringGraph, v, subset, alpha, beta) -> [int]:$/;"	f
golang_graph_to_graph	check_claim.py	/^def golang_graph_to_graph(edge_data):$/;"	f
golang_graph_to_graph	pyecol/utils.py	/^def golang_graph_to_graph(edge_data) -> Graph:$/;"	f
golang_graph_to_graphtool_graph	check_claim.py	/^def golang_graph_to_graphtool_graph(edge_data):$/;"	f
graph	xc/graph.h	/^} graph;$/;"	t	typeref:struct:__anon2
graph6_get_bytes_needed	xc/graph6.c	/^int graph6_get_bytes_needed(int n) {$/;"	f
graph6_get_size	ecol/graph6.go	/^func graph6_get_size(data []byte) (cursor int, size int) {$/;"	f
graph6_get_size	xc/graph6.c	/^graph6_state graph6_get_size(char* data) {$/;"	f
graph6_state	xc/graph6.h	/^} graph6_state;$/;"	t	typeref:struct:__anon1
graph6_write_bytes	xc/graph6.c	/^void graph6_write_bytes(graph g, int n, char* buf) {$/;"	f
graph6_write_graph	ecol/graph6.go	/^func graph6_write_graph(data []byte, size int, graph *Graph) {$/;"	f
graph6_write_graph	xc/graph6.c	/^void graph6_write_graph(char* data, int cursor, int size, graph* g) {$/;"	f
graph_clear	xc/graph.c	/^void graph_clear(graph *g) {$/;"	f
graph_create	xc/graph.c	/^graph graph_create(int n) {$/;"	f
graph_free	xc/graph.c	/^void graph_free(graph* g) {$/;"	f
graph_get	xc/graph.c	/^int graph_get(graph* g, int u, int v) {$/;"	f
graph_get_degree	xc/graph.c	/^int graph_get_degree(graph* g, int u) {$/;"	f
graph_is_semicore	scripts/geng.py	/^def graph_is_semicore(g):$/;"	f
graph_max_degree	xc/graph.c	/^int graph_max_degree(graph* g) {$/;"	f
graph_next_uncoloured_edge	xc/graph.c	/^edge graph_next_uncoloured_edge(graph* g) {$/;"	f
graph_set	xc/graph.c	/^void graph_set(graph* g, int u, int v, int colour) {$/;"	f
graph_to_golang_graph	pyecol/utils.py	/^def graph_to_golang_graph(g: Graph) -> list:$/;"	f
graphcheck	xc/gc.c	/^} graphcheck;$/;"	t	typeref:struct:__anon4	file:
graphcheck_alloc	xc/gc.c	/^void graphcheck_alloc(graphcheck* gc, int need_advanced) {$/;"	f
graphcheck_free	xc/gc.c	/^void graphcheck_free(graphcheck* gc, int need_advanced) {$/;"	f
graphcheck_update	xc/gc.c	/^void graphcheck_update(graphcheck* gc, int need_advanced) {$/;"	f
graphs_from_stdin	filter_isomorphic.py	/^def graphs_from_stdin():$/;"	f
has_cycle	xc/gc.c	/^int has_cycle(graph g) {$/;"	f
help	xc/cg.c	/^static const char* help =$/;"	v	file:
help	xc/gc.c	/^static const char* help =$/;"	v	file:
i	xc/graph.h	/^    int i;$/;"	m	struct:__anon3
init_map	xc/xc.c	/^void init_map(int* map, int size) {$/;"	f
isCyclicUtil	pyecol/utils.py	/^    def isCyclicUtil(v, visited, parent):$/;"	f	function:contains_cycle
is_class_one	pyecol/utils.py	/^def is_class_one(G: ColouringGraph):$/;"	f
is_connected	scripts/graphgen.py	/^def is_connected(G: Graph, core):$/;"	f
is_cyclic	scripts/graphgen.py	/^def is_cyclic(G, subset):$/;"	f
is_overfull	ecol/utils.go	/^func is_overfull(g *Graph) bool {$/;"	f
is_overfull	pyecol/utils.py	/^def is_overfull(g: Graph) -> bool:$/;"	f
is_overfull	scripts/graphgen.py	/^def is_overfull(G: Graph):$/;"	f
is_valid_core	scripts/graphcheck.py	/^def is_valid_core(g: Graph, neighbours, core) -> bool:$/;"	f
is_valid_semicore	scripts/graphcheck.py	/^def is_valid_semicore(g: Graph, neighbours, core) -> bool:$/;"	f
j	xc/graph.h	/^    int j;$/;"	m	struct:__anon3
job_name	xc/gen.py	/^    job_name = 'job-{n}-{i}-{p}'.format(n=n, i=i, p=($/;"	v
main	check_claim.py	/^def main():$/;"	f
main	data/check_claim.py	/^def main():$/;"	f
main	data/check_edge_critical.py	/^def main():$/;"	f
main	data/check_vertex_critical.py	/^def main():$/;"	f
main	data/produce_graphs.py	/^def main():$/;"	f
main	ecol/bf.go	/^package main$/;"	p
main	ecol/counting.go	/^package main$/;"	p
main	ecol/counting_heuristic.go	/^package main$/;"	p
main	ecol/erdos_renyi_task.go	/^package main$/;"	p
main	ecol/graph.go	/^package main$/;"	p
main	ecol/graph6.go	/^package main$/;"	p
main	ecol/graphcheck.go	/^package main$/;"	p
main	ecol/heuristic.go	/^package main$/;"	p
main	ecol/main.go	/^func main() {$/;"	f
main	ecol/main.go	/^package main$/;"	p
main	ecol/utils.go	/^package main$/;"	p
main	ecol/vm.go	/^package main$/;"	p
main	scripts/complete_bipartite_process.py	/^def main():$/;"	f
main	scripts/core_3_test.py	/^def main():$/;"	f
main	scripts/erdos_renyi_benchmark.py	/^def main():$/;"	f
main	scripts/erdos_renyi_process.py	/^def main():$/;"	f
main	scripts/gen_nx.py	/^def main():$/;"	f
main	scripts/geng.py	/^def main():$/;"	f
main	scripts/geng_raw.py	/^def main():$/;"	f
main	scripts/just_core.py	/^def main():$/;"	f
main	scripts/plot_diff.py	/^def main():$/;"	f
main	scripts/plotall.py	/^def main():$/;"	f
main	xc/cg.c	/^int main(int argc, char* argv[]) {$/;"	f
main	xc/gc.c	/^int main(int argc, char* argv[]) {$/;"	f
main	xc/resmod.c	/^int main(int argc, char* argv[]) {$/;"	f
main	xc/xc.c	/^int main(int argc, char* argv[]) {$/;"	f
max_degree	ecol/utils.go	/^func max_degree(g *Graph) int {$/;"	f
max_degree	pyecol/utils.py	/^def max_degree(G: Graph):$/;"	f
maximal_fan	pyecol/misra_gries.py	/^def maximal_fan(G: ColouringGraph, X, Y):$/;"	f
misra_gries	pyecol/misra_gries.py	/^def misra_gries(G: ColouringGraph) -> ColouringGraph:$/;"	f
mod	xc/gen.py	/^mod = 96 * 4$/;"	v
n	xc/gen.py	/^n = 12$/;"	v
name	setup.py	/^    name="pyecol",$/;"	v
neighbours	pyecol/graph.py	/^    def neighbours(self, node):$/;"	m	class:Graph
nodes	pyecol/graph.py	/^    def nodes(self):$/;"	m	class:Graph
num_edges	pyecol/graph.py	/^    def num_edges(self):$/;"	m	class:Graph
num_uncoloured	xc/graph.h	/^    int num_uncoloured;$/;"	m	struct:__anon2
nx2graph	scripts/gen_nx.py	/^def nx2graph(G: nx.Graph):$/;"	f
overfull	xc/gc.c	/^    int overfull;$/;"	m	struct:__anon4	file:
packages	setup.py	/^    packages=setuptools.find_packages(),$/;"	v
plot_graph	pyecol/utils.py	/^def plot_graph(G: Graph, with_labels=True, node_label="node_num"):$/;"	f
prog	xc/gen.py	/^prog = "xc\/xc 1500"$/;"	v
random	xc/gen.py	/^random = False$/;"	v
randrange	xc/cg.c	/^int randrange(int m, int n) {$/;"	f
refilter	xc/gen.py	/^refilter = False$/;"	v
remap	xc/xc.c	/^void remap(xorshift64s_state *state, int* map, int* ed, graph* g, int num_uncoloured) {$/;"	f
rotate	pyecol/misra_gries.py	/^def rotate(G: ColouringGraph, v, W, colour):$/;"	f
run	xc/gen.py	/^run = 0$/;"	v
run_command	scripts/geng.py	/^def run_command(n, delta, min_delta, underfull):$/;"	f
run_command	scripts/geng_raw.py	/^def run_command(n, delta, min_delta, underfull):$/;"	f
showhelp	xc/cg.c	/^int showhelp(int code) {$/;"	f
showhelp	xc/gc.c	/^int showhelp(int code) {$/;"	f
shuffle	xc/xc.c	/^void shuffle(xorshift64s_state *state, int* x, int n) {$/;"	f
size	xc/graph.h	/^    int size;$/;"	m	struct:__anon2
size	xc/graph6.h	/^    int size;$/;"	m	struct:__anon1
subgraph	pyecol/graph.py	/^    def subgraph(self, nodes):$/;"	m	class:Graph
switch	pyecol/utils.py	/^def switch(G: ColouringGraph, P: [int], alpha, beta):$/;"	f
switch_path	ecol/utils.go	/^func switch_path(cg *ColouringGraph, path []int, alpha, beta int) {$/;"	f
switch_path	xc/graph.c	/^void switch_path(graph* g, int* path, int length, int alpha, int beta) {$/;"	f
switch_path_containing	pyecol/utils.py	/^def switch_path_containing(G: ColouringGraph, v, alpha, beta) -> [int]:$/;"	f
task_template	xc/gen.py	/^        task_template = "cat \/ddn\/data\/hvcs85\/xc-{n}-{res}.out | {prog} > \/ddn\/data\/hvcs85\/xc-{n}-{res}-filtered.out &"$/;"	v
task_template	xc/gen.py	/^        task_template = "cat cores.g6 | xc\/cg -d5 -N50 -n1000 | {prog} > \/ddn\/data\/hvcs85\/xc-hzc-{res}.out &"$/;"	v
task_template	xc/gen.py	/^        task_template = "nauty\/geng -c {n} {res}\/{mod} | {prog} > \/ddn\/data\/hvcs85\/xc-{n}-{res}.out &"$/;"	v
task_template	xc/gen.py	/^        task_template = "nauty\/genrang -g -P2 {n} 10000000 | {prog} > \/ddn\/data\/hvcs85\/xc-{n}-{res}.out &"$/;"	v
tasks	xc/gen.py	/^    tasks = "\\n".join(task_template.format(n=n, res=((i * cores) + res), mod=mod, prog=prog) for res in range(cores))$/;"	v
test_bipartite	scripts/test.py	/^def test_bipartite(f):$/;"	f
test_general	scripts/test.py	/^def test_general(f):$/;"	f
test_random	scripts/test.py	/^def test_random(f):$/;"	f
u	scripts/relabel.py	/^        u = json.loads(line)$/;"	v
unique_values	ecol/bf.go	/^func unique_values(p []int) int {$/;"	f
url	setup.py	/^    url="https:\/\/github.com\/eugene-eeo\/ecol",$/;"	v
valid_semicore	ecol/graphcheck.go	/^func valid_semicore(gc *GraphCheckMetadata) bool {$/;"	f
validate_colouring	ecol/utils.go	/^func validate_colouring(g *Graph) bool {$/;"	f
validate_colouring	pyecol/utils.py	/^def validate_colouring(G: Graph):$/;"	f
verify_colouring	xc/graph.c	/^int verify_colouring(graph *g) {$/;"	f
version	setup.py	/^    version="0.1.0",$/;"	v
vizing_heuristic	ecol/heuristic.go	/^func vizing_heuristic(cg *ColouringGraph) {$/;"	f
vizing_heuristic	pyecol/heuristic.py	/^def vizing_heuristic(G: ColouringGraph):$/;"	f
vizing_heuristic	xc/vizing_heuristic.c	/^int vizing_heuristic(graph* g, int* P, int delta) {$/;"	f
vm_perform	ecol/vm.go	/^func vm_perform(config *VMConfig) {$/;"	f
vm_task	ecol/vm.go	/^func vm_task(config *VMConfig, input VMInput) VMOutput {$/;"	f
wrap	pyecol/utils.py	/^    def wrap(cls, g: Graph):$/;"	m	class:ColouringGraph
xorshift64s	xc/xc.c	/^uint64_t xorshift64s(xorshift64s_state *state)$/;"	f
xorshift64s_state	xc/xc.c	/^typedef struct xorshift64s_state {$/;"	s	file:
xorshift64s_state	xc/xc.c	/^} xorshift64s_state;$/;"	t	typeref:struct:xorshift64s_state	file:
